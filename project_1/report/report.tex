\documentclass{article}

\usepackage{parskip}
\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2cm, right=2cm]{geometry}
\usepackage{amsmath}     % Math formulas
\usepackage{booktabs}    % High-quality tables
\usepackage{graphicx}    % Images (for placeholders)
\usepackage{placeins}

\title{\Huge Numerical Solution of 2D Heat Conduction}
\author{\normalsize Yifan Zhang  2025251018}
\date{\normalsize \today}

\begin{document}
\maketitle

\section*{Problem Statement}
Consider the 2D heat conduction equation:
$$
\frac{\partial T}{\partial t} = \alpha \left( \frac{\partial^2 T}{\partial x^2} + \frac{\partial^2 T}{\partial y^2} \right)
$$
where $T(x, y, t)$ is the temperature, $\alpha = 1$ is the thermal diffusivity, and the domain is $0 \le x, y \le 1$ with Dirichlet boundary conditions $T(0, y, t) = T(1, y, t) = T(x, 0, t) = T(x, 1, t) = 0$ for $t > 0$.

The initial condition is:
$$
T(x, y, 0) = \sin(\pi x) \sin(\pi y)
$$
The exact solution is:
$$
T(x, y, t) = e^{-2\pi^2 t} \sin(\pi x) \sin(\pi y)
$$

\section*{Problem Solve}

\subsection*{1. Discretizeion}

To solve the 2D heat conduction equation numerically, we can use the explicit finite difference method. We discretize the spatial domain into a grid with spacing $\Delta x = \Delta y = h$ and the time domain with time step $\Delta t$. The finite difference approximation for the spatial derivatives is given by:
$$
\delta_x^2 T_{i,j} = \frac{T_{i-1,j} - 2T_{i,j} + T_{i+1,j}}{h^2}
$$
$$
\delta_y^2 T_{i,j} = \frac{T_{i,j-1} - 2T_{i,j} + T_{i,j+1}}{h^2}
$$

\subsection*{2. Crank-Nicolson Method}

The CN scheme uses a central difference for the time derivative (at time $n+\frac{1}{2}$) and an average of the spatial derivatives at times $n$ and $n+1$. This makes it an implicit, second-order accurate scheme.

$$
\frac{T_{i,j}^{n+1} - T_{i,j}^n}{\Delta t} = \frac{\alpha}{2} \left[ (\delta_x^2 + \delta_y^2)T_{i,j}^{n+1} + (\delta_x^2 + \delta_y^2)T_{i,j}^n \right]
$$

Let $r = \frac{\alpha \Delta t}{2 h^2}$. Rearranging the equation to move terms at $n+1$ to the left side:
$$
\left(1 - r(\delta_x^2 + \delta_y^2)\right) T_{i,j}^{n+1} = \left(1 + r(\delta_x^2 + \delta_y^2)\right) T_{i,j}^n
$$

This is a large, sparse system of linear equations $\mathbf{A} \mathbf{T}^{n+1} = \mathbf{b}$, where $\mathbf{b}$ is the right-hand side (RHS) calculated from $T^n$. Solving this $N^2 \times N^2$ system directly is computationally expensive.

\subsection*{3. Approximate Factorization (AF)}

To efficiently solve the CN scheme, we can use the Approximate Factorization (AF) method. The idea is to factor the operator into two simpler operators that can be solved sequentially. We approximate:
$$
I - r(\delta_x^2 + \delta_y^2) \approx (I - r\delta_x^2)(I - r\delta_y^2)
$$

The error of this approximation is $O(\Delta t^2)$, which is consistent with the temporal accuracy of the CN scheme.

Substituting this into the CN scheme, we get:
$$
(I - r\delta_x^2)(I - r\delta_y^2) T^{n+1} = \text{RHS}
$$
where $\text{RHS} = (1 + r(\delta_x^2 + \delta_y^2)) T^n$.

This equation can be solved in two 1D steps:

\textbf{Step 1 (X-Sweep):} Define an intermediate variable $T^* = (I - r\delta_y^2) T^{n+1}$
$$
(I - r\delta_x^2) T^* = \text{RHS}
$$
For each $j$ (from 1 to $N$), this constitutes a tridiagonal system:
$$
-r T_{i-1,j}^* + (1+2r) T_{i,j}^* - r T_{i+1,j}^* = \text{RHS}_{i,j} \quad \text{for } i=1, \dots, N
$$

\textbf{Step 2 (Y-Sweep):} Solve for $T^{n+1}$
$$
(I - r\delta_y^2) T^{n+1} = T^*
$$
For each $i$ (from 1 to $N$), this constitutes another tridiagonal system:
$$
-r T_{i,j-1}^{n+1} + (1+2r) T_{i,j}^{n+1} - r T_{i,j+1}^{n+1} = T_{i,j}^* \quad \text{for } j=1, \dots, N
$$
Both steps involve solving $N$ independent tridiagonal systems of size $N \times N$.

\subsection*{4. Tridiagonal Matrix Algorithm (TDMA)}

We implement a custom \texttt{tdma\_solver} (Thomas Algorithm) to efficiently solve tridiagonal systems of the form $A \mathbf{x} = \mathbf{d}$.
For the system:
$$
a_i x_{i-1} + b_i x_i + c_i x_{i+1} = d_i
$$
The algorithm solves for $\mathbf{x}$ in $O(N)$ complexity with one forward elimination pass and one backward substitution pass.

\subsection*{5. Results and Discussion}

We run the simulation with $N=40$ and $\Delta t = 0.001$. The figures below show the numerical and exact solutions at $t=0.05$.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.45\textwidth]{images/exact_temperature_t0.05.png}
  \hfill
  \includegraphics[width=0.45\textwidth]{images/Numerical_temperature_t0.05.png}
  \caption{3D surface plot of the temperature field at t=0.05.}
  \label{fig:temp_field}
\end{figure}

As shown, the numerical and exact solutions are visually indistinguishable, indicating high accuracy. The temperature field decays from the initial $\sin(\pi x)\sin(\pi y)$ shape as expected.

\subsubsection*{Spatial Convergence Analysis}

We fix $\Delta t = 0.001$ (small enough for temporal error to be negligible) and vary the spatial resolution $N$.

\textbf{Absolute Error Maps ($|T_{num} - T_{exact}|$ at $t=0.05$):}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.45\textwidth]{images/error_map_spatial_N10.png}
  \hfill
  \includegraphics[width=0.45\textwidth]{images/error_map_spatial_N20.png}

  \vspace{0.5cm} % Vertical space between rows

  \includegraphics[width=0.45\textwidth]{images/error_map_spatial_N40.png}
  \hfill
  \includegraphics[width=0.45\textwidth]{images/error_map_spatial_N80.png}
  \caption{Absolute error maps for spatial convergence (t=0.05).}
  \label{fig:spatial_error_maps}
\end{figure}

\textbf{Order of Convergence:}
We calculate the Root Mean Square Error (RMSE) for each grid and estimate the order of convergence $p$, where $\text{RMSE} \propto (\Delta x)^p$.

$$
p = \log(\text{RMSE}_1 / \text{RMSE}_2) / \log(\Delta x_1 / \Delta x_2)
$$

\begin{table}[htbp]
  \centering
  \begin{tabular}{cccc}
    \toprule
    N & $\Delta x$ & RMSE (at $t=0.05$) & Order $p$ \\
    \midrule
    10 & 0.1000 & 9.369e-04 & - \\
    20 & 0.0500 & 1.079e-04 & 3.12 \\
    40 & 0.0250 & 1.371e-04 & -0.35 \\
    80 & 0.0125 & 2.049e-04 & -0.58 \\
    \bottomrule
  \end{tabular}
  \caption{Spatial convergence data (t=0.05, $\Delta t = 0.001$)}
  \label{tab:spatial_convergence}
\end{table}

\textbf{RMSE vs. $\Delta t$ (Log-Log Plot):}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/convergence_spatial.png}
  \caption{Log-log plot for spatial convergence.}
  \label{fig:spatial_loglog}
\end{figure}

The spatial convergence result is supposed to indicate that the method achieves approximately second-order accuracy in space.
But I don't get the expected second-order convergence consistently, possibly due to the dominance of temporal errors or numerical artifacts at coarser grids. Further refinement and analysis may be needed.

\subsubsection*{Temporal Convergence Analysis}

We fix $N = 40$ (fine enough for spatial error to be negligible) and vary the time step $\Delta t$.

\textbf{Absolute Error Maps ($|T_{num} - T_{exact}|$ at $t=0.05$):}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.45\textwidth]{images/error_map_temporal_dt0.01.png}
  \hfill
  \includegraphics[width=0.45\textwidth]{images/error_map_temporal_dt0.005.png}

  \vspace{0.5cm} % Vertical space between rows

  \includegraphics[width=0.45\textwidth]{images/error_map_temporal_dt0.0025.png}
  \hfill
  \includegraphics[width=0.45\textwidth]{images/error_map_temporal_dt0.00125.png}

  \caption{Absolute error maps for temporal convergence (t=0.05).}
  \label{fig:temporal_error_maps}
\end{figure}

\textbf{Order of Convergence:}
$p = \log(\text{RMSE}_1 / \text{RMSE}_2) / \log(\Delta t_1 / \Delta t_2)$

\begin{table}[htbp]
  \centering
  \caption{Temporal convergence data (t=0.05, $N = 40$)}
  \label{tab:temporal_convergence}
  \begin{tabular}{ccc}
    \toprule
    $\Delta t$ & RMSE (at $t=0.05$) & Order $p$ \\
    \midrule
    0.01 & 2.492e-03 & - \\
    0.005 & 1.109e-03 & 1.17 \\
    0.0025 & 4.878e-04 & 1.18 \\
    0.00125 & 1.944e-04 & 1.33 \\
    \bottomrule
  \end{tabular}
\end{table}

\textbf{RMSE vs. $\Delta t$ (Log-Log Plot):}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{images/convergence_temporal.png}
  \caption{Log-log plot for temporal convergence.}
  \label{fig:temporal_loglog}
\end{figure}

\textbf{Analysis:} The results (Table \ref{tab:temporal_convergence}) show the order of convergence increase.
But the order is around 1.2 to 1.3, which is lower than the expected second-order accuracy in time for the Crank-Nicolson scheme.
This discrepancy may arise from the interaction between spatial and temporal discretization errors, as well as numerical artifacts.

Further investigation is needed to isolate the sources of error and improve the overall accuracy of the method.

\FloatBarrier
\subsubsection*{Computational Efficiency}

We measure the computational time for the largest grid ($N=80$) and $\Delta t = 0.001$, running to $t=0.1$ (100 time steps).

\begin{itemize}
  \item \textbf{Platform:} [Please insert your CPU/environment here] (on our test system)
  \item \textbf{Total Time Steps:} $t_{final} / \Delta t = 0.1 / 0.001 = 100$
  \item \textbf{Computation Time:} ~0.6710 seconds
\end{itemize}

\textbf{Discussion:}
The AF (ADI) method is extremely efficient. At each time step, we perform:
\begin{enumerate}
  \item RHS Calculation: $O(N^2)$
  \item X-Sweep: $N$ TDMA solves, each $O(N)$. Total $O(N^2)$.
  \item Y-Sweep: $N$ TDMA solves, each $O(N)$. Total $O(N^2)$.
\end{enumerate}
The total complexity per time step is therefore $O(N^2)$. This is far superior to the $O(N^3)$ or $O(N^4)$ complexity of solving the $N^2 \times N^2$ system using a sparse direct solver (like \texttt{spsolve}). This efficiency makes the method highly suitable for large 2D and 3D problems.

\section*{Code}
The complete code for the implementation can be found in the \texttt{src/main.py} file of the project repository.
\end{document}
